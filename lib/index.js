function mewt(a){const f=Array.isArray(a),g=f?(l)=>[...l]:(l)=>Object.assign({},l),h=(l)=>{throw new Error(`${l?'array':'object'} is immutable`)},i=(l)=>(...m)=>{const n='reverse sort splice fill copyWithin'.includes(l),o='filter map concat slice'.includes(l),p=o?a:g(a),q=p[l](...m),r=n||o?mewt(q):q;return'push pop shift unshift'.includes(l)?[r,mewt(p)]:r},j={$set(l,m){const n=g(a);return n[l]=m,mewt(n)},$unset(l){if(f&&Number.isInteger(l)&&0<=l)return mewt(a.slice(0,l).concat(a.slice(l+1)));const m=g(a);return delete m[l],mewt(m)}};if('object'!=typeof a||!a)throw new Error('mewt accepts array or object');let k={get:(l,m)=>{return j[m]||a[m]&&({}.hasOwnProperty.call(a,m)?a[m]:i(m))}};return['setPrototypeOf','defineProperty','deleteProperty'].forEach((l)=>{k[l]=h}),new Proxy(a,k)}module.exports=mewt;